# volatile 解析
---
* [内存模型](#内存模型)
  * [简述](#简述)
  * [案例](#案例)
  * [问题](#问题)
  * [解决方案](#解决方案)
* [并发编程](#并发编程)
  * [原子性](#原子性)
  * [可见性](#可见性)
  * [有序性](#有序性)
* [Java 内存模型](#Java内存模型)
* [volatile](#volatile)
* [附录](#附录)
## 内存模型
### 简述
```
计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存当中的，这时就存在一个问题，由于CPU执行速度比较快，而从主存读取数据和向主存写入数据的过程相对慢很多，因此如果任何时候对数据的操作都要通过和主存的交互来进行，会大大降低指令执行的速度。为了解决这个问题，就有了高速缓存的出现。
程序在运行过程时，计算机会将运算过程中用到的数据从主存复制一份至高速缓存，这样CPU在进行计算时会直接与高速缓存进行交互(存取数据)，当运算结束之后，会将高速缓存中的数据刷新到主存中
```
### 案例
```
假设线程A与线程B共享变量i，而此时两个线程都需要执行i = i + 1,根据上述理论，会出现以下情形：
1. 线程A尚未将i最新值从高速缓存刷新到主存,此时线程B从主存复制i的值进入高速缓存
2. 线程A已将i最新值从高速缓存刷新到主存,此时线程B从主存复制i的值进入高速缓存
......
```
### 问题
```
情形1：两个线程运行完毕之后，i的值最终是被加1，假设i初始值是1，那么运行结果是2
情形2：两个线程运行完毕之后，i的值最终是被加2，假设i初始值是1，那么运行结果是3
这就是典型的缓存不一致现象
```
### 解决方案
```
- 总线锁机制
- 缓存一致性协议
```
## 并发编程
### 原子性
```
一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行.
```
### 可见性
```
当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
```
### 有序性
```
程序执行的顺序按照代码的先后顺序执行
```
## Java内存模型
```
为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在Java内存模型中，也会存在缓存一致性问题和指令重排序的问题。
Java内存模型规定所有的成员变量，静态变量都存在主存中，每个线程都有自己的工作内存。线程对这些变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
```
## volatile
```
底层的实现原理是依赖lock前缀指令，而lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它提供以下功能：
- 确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面。即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
- 强制将对缓存的修改操作立即写入主存
- 如果是写操作，它会导致其他线程工作内存对应的缓存无效
```
## 附录
```
- volatile关键字能够保证可见性，但是不能保证原子性
- Java中只有简单的读取、赋值（必须是将数字赋值给某个变量）才是原子操作。需要注意在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。貌似最新的JDK版本，JVM已经保证了它的原子性。
```

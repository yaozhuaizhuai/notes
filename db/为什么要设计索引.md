**问题1. 数据库为什么要设计索引？**

图书馆存了1000W本图书，要从中找到《架构师之路》，一本本查，要查到什么时候去？

于是，图书管理员设计了一套规则：

（1）一楼放历史类，二楼放文学类，三楼放IT类…

（2）IT类，又分软件类，硬件类…

（3）软件类，又按照书名音序排序…

以便快速找到一本书。
 
与之类比，数据库存储了1000W条数据，要从中找到name=”shenjian”的记录，一条条查，要查到什么时候去？

于是，要有索引，用于提升数据库的查找速度。

**问题2. 哈希(hash)比树(tree)更快，索引结构为什么要设计成树型？**

加速查找速度的数据结构，常见的有两类：

（1）哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是O(1)；

（2）树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是O(lg(n))；

可以看到，不管是读请求，还是写请求，哈希类型的索引，都要比树型的索引更快一些，那为什么，索引结构要设计成树型呢？

**索引设计成树型，和SQL的需求相关**

对于这样一个单行查询的SQL需求：

select * from t where name=”shenjian”;

确实是哈希索引更快，因为每次都只查询一条记录。 

但是对于排序查询的SQL需求：

分组：group by

排序：order by

比较：<、>

…

哈希型的索引，时间复杂度会退化为O(n)，而树型的“有序”特性，依然能够保持O(log(n)) 的高效率。
 
InnoDB并不支持哈希索引。

**问题3. 数据库索引为什么使用B+树？**

为了保持知识体系的完整性，简单介绍下几种树。

第一种：二叉搜索树

![](https://github.com/c-agam/notes/blob/master/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png)

二叉搜索树，它为什么不适合用作数据库索引？

（1）当数据量大的时候，树的高度会比较高，数据量大的时候，查询会比较慢；

（2）每个节点只存储一个记录，可能导致一次查询有很多次磁盘IO；

第二种：B树

![](https://github.com/c-agam/notes/blob/master/images/B%E6%A0%91.png)

B树，如上图，它的特点是：

（1）不再是二叉搜索，而是m叉搜索；

（2）叶子节点，非叶子节点，都存储数据；

（3）中序遍历，可以获得所有节点；

第三种：B+树

![](https://github.com/c-agam/notes/blob/master/images/B%2B%E6%A0%91.png)

B+树，如上图，仍是m叉搜索树，在B树的基础上，做了一些改进：

（1）非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；

（2）叶子之间，增加了链表，获取所有节点，不再需要中序遍历；

这些改进让B+树比B树有更优的特性：

（1）范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；

（2）叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；

（3）非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；

**附录**

https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961486&idx=1&sn=b319a87f87797d5d662ab4715666657f&chksm=bd2d0d528a5a84446fb88da7590e6d4e5ad06cfebb5cb57a83cf75056007ba29515c85b9a24c&mpshare=1&scene=23&srcid=0328NqcK5Ng6J0dTIJNMXrax#rd

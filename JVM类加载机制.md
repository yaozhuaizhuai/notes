* [前言](#前言)
  * [加载](#加载)
  * [验证](#验证)
  * [准备](#准备)
  * [解析](#解析)
  * [初始化](#初始化)
* [类加载器](#类加载器)
  * [双亲委派模型](#双亲委派模型)
  * [打破双亲委派模型](#打破双亲委派模型)
    * [第一次破坏](#第一次破坏)
    * [第二次破坏](#第二次破坏)
    * [第三次破坏](#第三次破坏)
# 前言
![](https://agam-blog-image.oss-cn-hangzhou.aliyuncs.com/24d129b75feca19b704ed4bbe169bafaa45.jpg)
```
- 类加载全过程如图所示，其中验证，准备，解析又被称为连接阶段。类加载过程的五个阶段，除了解析阶段，其他都是顺序开始，但是不是顺序执行的，也就是说在整个过程中会出现并行执行的现象，例如在验证开始之后，但未结束时，准备阶段就开始执行了。而解析阶段不一定在这个顺序当中主要原因是为了支持动态绑定（又称为运行时绑定）
- 绑定：指的是把一个方法的调用与方法所在的类(方法主体)关联起来
- 静态绑定：即在程序执行方法之前就已经被绑定，简单来说再编译期就进行绑定，在java当中被final、static、private修饰的方法，以及构造方法都是属于静态绑定，即编译期绑定。
- 动态绑定：又称运行时绑定，在运行时根据具体对象的类型进行绑定，在java当中，几乎除了满足静态绑定的方法之外，所有方法都是动态绑定的（java当中运行时多态的重要实现根据）
```
## 加载
```
加载过程一般分为两种：第一种是预加载，即虚拟机启动时，加载JDK相关的类文件，如：java.lang.*,java,util.*等等，它们都是随着虚拟机的启动而被加载。第二种是运行时加载，即当虚拟机需要用到某个类的时候，会先从内存中查询有没有该类，如果没有该类，就会按照该类的全限定名来加载。
该阶段主要做一下事情：
- 获取.class文件二进制流
- 在堆当中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口（HotSpot虚拟机比较特殊，这个Class类放在了方法区当中）
- 将类信息，静态变量，方法字节码，常量等这些.class文件中的内容放入到方法区当中
```
## 验证
```
这一阶段的主要目的为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
```
## 准备
```
准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间
```
## 解析
```
解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程
```
## 初始化
```
初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码
```
# 类加载器
```
虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器:
- 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可的类库
- 扩展类加载器(Extension ClassLoader)：负责加JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库
- 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库
```
## 双亲委派模型
![](https://agam-blog-image.oss-cn-hangzhou.aliyuncs.com/c09cd5181e1afb47805dce476b1ba02ca91.jpg)
```
JVM默认是通过双亲委派模型来进行类加载的（如上图）。为什么说是默认呢？因为这个里面的双亲委派模型可以通过自定义类加载器从而被打破。另外从这个里面还能获知如果没有通过自定义类加载器来加载需要的类，那它肯定是遵循双亲委派模型。
```
## 打破双亲委派模型
### 第一次破坏
```
由于双亲委派模型是在JDK1.2之后才被引入的，而ClassLoader类jdk1.0时期就存在了。面对已经存在的用户自定义类加载器，Java设计者在引入双亲委派模型时不得不做出一些妥协。在此之前，用户去继承ClassLoader的唯一目的就是为了重写loadClass方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal，而这个方法唯一逻辑就是去调用loadClass方法
```
### 第二次破坏
```
双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决多个类加载加载同一个基础类的问题(越基础的类由越上层的加载器进行加载)，但是如果基础类又需要调用用户的代码，按照双亲委派模型来加载，这样就行不通了，那该如何解决这个问题呢？
为了解决这个问题，Java设计团队引入了一个不太优雅的设计，即线程上下文类加载器，这个类加载器可以通过Thread类setContextClassLoader方法进行设置，如果创建线程时还未设置，他将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。(Java中所有涉及SPI的加载动作基本上都采用这种方式，如JNDI、JDBC、JCE、JAXB和JBI等等)
```
### 第三次破坏
```
由于用户对程序动态性的追求导致的，如我们常说的：热部署，热替换
```

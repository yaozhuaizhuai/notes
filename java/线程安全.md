线程安全
---
Brian Goetz给出的定义：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得准确的结果，那这个对象是线程安全的。按照线程的"安全程度"由强至弱排序，我们可以将Java语言中各种操作共享的数据分为以下5类：

**（1）不可变**

在Java语言中(特指JDK1.5以后，即Java内存模型被修正之后的Java语言)，不可变对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采用任何的线程安全保护措施。

Java语言中：
* 如果共享数据是一个基本数据类型，那么只要在定义时使用关键字final修饰它就可以保证它的不可变。
* 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。

**（2）绝对线程安全**

绝对线程安全完全满足Brian Goetz给出的线程安全定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者够不需要任何额外的同步措施” 通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对线程安全的。我们可以通过Java API中一个不是“不是绝对线程安全”的线程安全类来看看这里的“绝对”是什么意思。

如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都绝对不会有异议，因为它的add,get和size这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，既使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不需要同步手段了,代码示例略。

**（3）相对线程安全**

相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

**（4）线程兼容**

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这种情况。

**（5）线程对立**

线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码很少出现而且通常都是有害的，应当尽量避免。

一个线程对立的例子是Thread类的suspend和resume方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发执行的话，无论调用时是否进行了同步，目标线程都是存在死锁的风险，如果suspend中断的线程就是即将要执行resume的那个线程，那就肯定要产生死锁了。

# 粘包，多包，封包，断包
---
## 一.前言
### 保护消息边界
传输协议把数据当作一条独立的消息在网络上传输，接收端只能接收独立的消息，也就是说接收端一次只能接收发送端发出的一个数据包
### 无保护消息边界
发送端连续发送数据，接收端有可能一次接收操作会接收多条数据
### TCP
每一个TCP套接字都有一对缓冲区，分别是发送缓冲区与接收缓冲区，可以用SO_SNDBUF套接字选项来改变这一缓冲区的大小。当应用进程调用write往套接字写数据，内核从应用进程缓冲区中拷贝所有数据到套接字的发送缓冲区，如果应用进程的缓冲区大于套接字的发送缓冲区或者是套接字的发送缓冲区中已满：1.阻塞模式下，应用进程将被挂起，内核将不从write返回，直到应用进程缓冲区中的所有数据都拷贝到套接字发送缓冲区。因此，从一次TCP套接字的write调用并成功返回仅仅表示我们可以重新使用应用进程缓冲区，并不是告诉我们对方收到数据。2.非阻塞模式下，内核将从write返回，但应用进程缓冲区有可能存在未写入发送缓冲区的数据。TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。
### UDP
任何UDP套接字都有发送缓冲区大小，可以用SO_SNDBUF套接字选项更改，不过它仅仅是可写套接字UDP数据报大小上限。如果一个应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。既然UDP是不可靠的，它不必保存应用进程数据的一个副本，因此无需一个真正的发送缓冲区。（应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，然而当该数据被发送之 后，这个副本被数据链路层丢弃了）
## 二.无保护消息边界带来的问题(TCP)
### 场景
假设应用连续发送两条消息msg-A与msg-B，接收端在接收数据的时候有可能遇到以下情行
1. 先接收到msg-A，后接收到msg-B
2. 一次性接收到msg-A与msg-B
3. 先接收到msg-A的部分消息，接着接收到msg-A剩余消息和整个msg-B
4. 先接收到msg-A全部消息与部分msg-B消息，接着接收到msg-B剩余消息
5. 先接收到msg-A部分消息，再接收到msg-A剩余消息，最后接收到msg-B全部消息
......
### 问题
- 第1种：比较理想，我们无需干预即可分辨出具体的消息
- 第2种：多包
- 第3种：断包+粘包
- 第4种：粘包+断包
- 第5种：断包
### 原因
- 多包：TCP缓冲区>>应用缓冲区
- 粘包：TCP缓冲区>应用缓冲区
- 断包：TCP缓冲区<应用缓冲区
### 解决方案
简述：无论断包还是粘包问题，解决思路都是在如何划定消息边界，只要包的边界能够顺利划定，上述问题就都能得到很好的解决。
- 方案一：消息定长,不够空位补空格 
- 方案二：包尾增加回车换行符进行分割（FTP） 
- 方案三：消息分为消息头和消息体，消息头中包含消息长度的字段（通常设计思路为消息头的第一个字段使用32位来表示消息总长）

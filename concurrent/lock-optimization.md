# Lock optimization
---
高效并发是从JDK1.5到JDK1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大精力去对Java中锁进行优化，如适应性自旋，锁消除，锁粗化，轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。作为一个Java开发，其实只需要知道你想加锁的时候使用synchronized就可以了，具体的锁优化是虚拟机根据竞争情况自行决定的。也就是说，在JDK1.5以后，我们即将介绍的一些概念都被封装在synchronized中了。

## 自旋锁
JDK1.6之前，synchronized的实现会直接调用ObjectMonitor的enter和exit，这是一种互斥锁，为了表示它对性能的影响，又被我们称之为重量级锁。这种互斥锁在互斥同步上对性能的影响很大，Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到内核态，因此状态转换是需要花费很多处理器的时间。

Java虚拟机工程们在分析过大量数据后发现：共享数据的锁定状态一般只会持续很短的一段时间，为了这段时间去挂起和恢复线程其实并不值得(其实说的就是线程状态切换)。**如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。**

自旋锁在JDK1.4中已经引入，但在JDK1.6中才默认开启。很多人在对于自旋锁的概念不是很清楚的时候可能会有以下疑问：这么听上去，自旋锁好像和阻塞锁没啥区别，反正都是等着嘛。其实自旋锁与阻塞锁最大的区别就是：**到底放不放弃处理器的执行时间**。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但阻塞锁是放弃了CPU时间，进入等待区，等待被唤醒。而自旋锁不停的在那里执行循环体，不进行线程状态改变，所以响应速度更快。但当线程数不断增加时，自旋锁会导致系统性能会下降明显，因为每个线程都需要执行循环体，占用CPU时间。如果线程竞争不激烈并且保持锁的时间短，适合使用自旋锁。

## 锁消除
除了自旋锁，JDK中还有一种锁优化被称之为锁消除。举个例子：

**你去银行取钱，所有情况下都需要取号，并且等待吗？其实有的时候是不用的，当银行办理业务的人不是很多的时候，可能根本不用取号，直接到柜台面前就能办理。**

上面这种例子，在锁优化中被称作“锁消除”，是JIT编译器对内部锁的具体实现做的一种优化。在动态编译同步代码块的时候，JIT编译器可以解除一种被称为逃逸分析的技术来判断同步块使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块在使用锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在
编译这个同步块的时候就会取消对这部分代码的同步。

## 锁粗化
很多人都知道，在代码中，需要加锁的时候，我们提倡尽量减小锁的粒度，这样可以避免不必要的阻塞。这也是很多人用同步代码块来替换同步方法的原因，因为这样的锁粒度往往会更小一些。大部分情况下，减少锁的粒度是很正确的做法，只有一种特殊情况下，会发生一种叫做锁粗化的优化。例如：我们在一个循环体里面synchronized，也就是说对同一个对象反复加锁解锁，这样其实很耗费资源的。这种情况可以适当放宽锁的范围，减少性能开销。
